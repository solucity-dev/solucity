generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id               String             @id @default(cuid())
  phone            String?            @unique
  email            String             @unique
  name             String?
  surname          String?
  passwordHash     String
  role             Role
  status           UserStatus         @default(ACTIVE)
  twoFactorEnabled Boolean            @default(false)
  failedLoginCount Int                @default(0)
  lastLoginAt      DateTime?
  createdAt        DateTime           @default(now())
  updatedAt        DateTime           @updatedAt
  chatMessages     ChatMessage[]      @relation("UserChatMessages")
  customer         CustomerProfile?
  notifications    Notification[]
  orderEvents      OrderEvent[]       @relation("UserOrderEvents")
  passwordsReset   PasswordReset[]
  pushTokens       PushToken[]        @relation("UserPushTokens")
  reviewsGiven     Rating[]           @relation("UserReviews")
  refreshTokens    RefreshToken[]
  specialist       SpecialistProfile?
  termsAcceptances TermsAcceptance[]
  preferences      UserPreference?

  @@index([status])
  @@index([lastLoginAt])
}

model CustomerProfile {
  id               String         @id @default(cuid())
  userId           String         @unique
  defaultAddressId String?
  createdAt        DateTime       @default(now())
  updatedAt        DateTime       @updatedAt
  avatarUrl        String?
  defaultAddress   Address?       @relation("CustomerDefaultAddress", fields: [defaultAddressId], references: [id])
  user             User           @relation(fields: [userId], references: [id], onDelete: Cascade)
  orders           ServiceOrder[] @relation("CustomerOrders")
}

model SpecialistProfile {
  id                String                     @id @default(cuid())
  userId            String                     @unique
  bio               String?
  visitPrice        Int?
  currency          String?
  availableNow      Boolean                    @default(false)
  kycStatus         VerificationStatus         @default(UNVERIFIED)
  points            Int                        @default(0)
  badge             Badge                      @default(BRONZE)
  ratingAvg         Float                      @default(0)
  ratingCount       Int                        @default(0)
  statsFinished     Int                        @default(0)
  statsCanceled     Int                        @default(0)
  centerLat         Float?
  centerLng         Float?
  radiusKm          Float?
  availability      Json?
  createdAt         DateTime                   @default(now())
  updatedAt         DateTime                   @updatedAt
  avatarUrl         String?
  pricingLabel      String?
  specialtyHeadline String?                    @db.VarChar(60)
  officeAddressId   String?                    @unique
  serviceModes      ServiceMode[]
  businessName      String?                    @db.VarChar(80)
  kycSubmissions    KycSubmission[]
  orders            ServiceOrder[]             @relation("SpecialistOrders")
  backgroundCheck   SpecialistBackgroundCheck?
  certifications    SpecialistCertification[]
  officeAddress     Address?                   @relation("SpecialistOfficeAddress", fields: [officeAddressId], references: [id])
  user              User                       @relation(fields: [userId], references: [id], onDelete: Cascade)
  searchIndex       SpecialistSearchIndex?
  specialties       SpecialistSpecialty[]
  subscription      Subscription?

  @@index([badge, ratingAvg, points], map: "idx_spec_rank")
  @@index([availableNow])
}

/// *
/// * puente especialista↔categoría (rubro)
model SpecialistSpecialty {
  id           String            @id @default(cuid())
  specialistId String
  categoryId   String
  category     ServiceCategory   @relation(fields: [categoryId], references: [id])
  specialist   SpecialistProfile @relation(fields: [specialistId], references: [id], onDelete: Cascade)

  @@unique([specialistId, categoryId])
  @@index([categoryId])
}

model ServiceCategoryGroup {
  id         String            @id @default(cuid())
  name       String            @unique
  slug       String            @unique
  isActive   Boolean           @default(true)
  sortOrder  Int?
  icon       String?
  color      String?
  createdAt  DateTime          @default(now())
  updatedAt  DateTime          @updatedAt
  categories ServiceCategory[]
}

model ServiceCategory {
  id                    String                    @id @default(cuid())
  groupId               String
  name                  String
  slug                  String                    @unique
  isActive              Boolean                   @default(true)
  createdAt             DateTime                  @default(now())
  updatedAt             DateTime                  @updatedAt
  requiresCertification Boolean                   @default(false)
  services              Service[]
  group                 ServiceCategoryGroup      @relation(fields: [groupId], references: [id])
  certifications        SpecialistCertification[]
  specs                 SpecialistSpecialty[]

  @@unique([groupId, name])
  @@index([groupId])
}

model Service {
  id          String          @id @default(cuid())
  categoryId  String
  name        String
  description String?
  basePoints  Int             @default(0)
  slaHours    Int             @default(0)
  basePrice   Int?
  createdAt   DateTime        @default(now())
  updatedAt   DateTime        @updatedAt
  category    ServiceCategory @relation(fields: [categoryId], references: [id])
  orders      ServiceOrder[]

  @@unique([categoryId, name])
  @@index([categoryId])
}

model Address {
  id                String             @id @default(cuid())
  formatted         String
  lat               Float
  lng               Float
  placeId           String?            @unique
  createdAt         DateTime           @default(now())
  updatedAt         DateTime           @updatedAt
  customerDefaults  CustomerProfile[]  @relation("CustomerDefaultAddress")
  orderLocations    ServiceOrder[]     @relation("OrderLocation")
  specialistOffices SpecialistProfile? @relation("SpecialistOfficeAddress")

  @@index([lat, lng])
}

model ServiceOrder {
  id                       String             @id @default(cuid())
  customerId               String
  specialistId             String?
  serviceId                String
  locationId               String?
  status                   OrderStatus        @default(PENDING)
  description              String?
  attachments              Json?
  scheduledAt              DateTime?
  preferredAt              DateTime?
  isUrgent                 Boolean            @default(false)
  autoCancelAt             DateTime?
  acceptDeadlineAt         DateTime?
  acceptDeadlineExtendedAt DateTime?
  agreedPrice              Int?
  createdAt                DateTime           @default(now())
  updatedAt                DateTime           @updatedAt
  addressText              String?
  serviceMode              ServiceMode        @default(HOME)
  chatThread               ChatThread?
  events                   OrderEvent[]
  rating                   Rating?
  customer                 CustomerProfile    @relation("CustomerOrders", fields: [customerId], references: [id])
  location                 Address?           @relation("OrderLocation", fields: [locationId], references: [id])
  service                  Service            @relation(fields: [serviceId], references: [id])
  specialist               SpecialistProfile? @relation("SpecialistOrders", fields: [specialistId], references: [id])

  @@index([status, scheduledAt], map: "idx_order_status_sched")
  @@index([customerId, status], map: "idx_order_customer")
  @@index([specialistId, status], map: "idx_order_specialist")
  @@index([status, acceptDeadlineAt], map: "idx_serviceOrder_status_deadline")
}

model OrderEvent {
  id        String       @id @default(cuid())
  orderId   String
  actorId   String
  type      String
  payload   Json?
  createdAt DateTime     @default(now())
  actor     User         @relation("UserOrderEvents", fields: [actorId], references: [id])
  order     ServiceOrder @relation(fields: [orderId], references: [id], onDelete: Cascade)

  @@index([orderId, createdAt])
}

model Rating {
  orderId    String       @id
  reviewerId String
  score      Int
  comment    String?
  tags       Json?
  createdAt  DateTime     @default(now())
  order      ServiceOrder @relation(fields: [orderId], references: [id], onDelete: Cascade)
  reviewer   User         @relation("UserReviews", fields: [reviewerId], references: [id])
}

model ChatThread {
  id        String        @id @default(cuid())
  orderId   String        @unique
  createdAt DateTime      @default(now())
  messages  ChatMessage[]
  order     ServiceOrder  @relation(fields: [orderId], references: [id], onDelete: Cascade)
}

model ChatMessage {
  id          String     @id @default(cuid())
  threadId    String
  senderId    String
  body        String
  attachments Json?
  deliveredAt DateTime?
  readAt      DateTime?
  createdAt   DateTime   @default(now())
  sender      User       @relation("UserChatMessages", fields: [senderId], references: [id])
  thread      ChatThread @relation(fields: [threadId], references: [id], onDelete: Cascade)

  @@index([threadId, createdAt])
}

model Notification {
  id        String    @id @default(cuid())
  userId    String
  type      String
  title     String
  body      String
  data      Json?
  readAt    DateTime?
  createdAt DateTime  @default(now())
  user      User      @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId, readAt])
}

model Subscription {
  id                 String             @id @default(cuid())
  specialistId       String             @unique
  status             SubscriptionStatus @default(TRIALING)
  currentPeriodStart DateTime
  currentPeriodEnd   DateTime
  trialEnd           DateTime?
  createdAt          DateTime           @default(now())
  updatedAt          DateTime           @default(now()) @updatedAt
  lastPaymentStatus  String?
  provider           String?
  providerSubId      String?
  lastPaymentId      String?
  specialist         SpecialistProfile  @relation(fields: [specialistId], references: [id], onDelete: Cascade)

  @@index([specialistId, status])
}

model TermsAcceptance {
  id         String   @id @default(cuid())
  userId     String
  version    String
  ip         String?
  userAgent  String?
  acceptedAt DateTime @default(now())
  user       User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId, version])
}

model RefreshToken {
  id        String   @id @default(cuid())
  userId    String
  token     String   @unique
  userAgent String?
  ip        String?
  expiresAt DateTime
  createdAt DateTime @default(now())
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId, expiresAt])
}

model PasswordReset {
  id        String    @id @default(cuid())
  userId    String
  otp       String
  expiresAt DateTime
  usedAt    DateTime?
  createdAt DateTime  @default(now())
  user      User      @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId, expiresAt])
}

model UserPreference {
  id            String  @id @default(cuid())
  userId        String  @unique
  theme         String?
  notifications Json?
  user          User    @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model SpecialistSearchIndex {
  id            String            @id @default(cuid())
  specialistId  String            @unique
  groupSlugs    String[]
  categorySlugs String[]
  centerLat     Float
  centerLng     Float
  radiusKm      Float
  ratingAvg     Float
  ratingCount   Int
  badge         Badge
  visitPrice    Int?
  availableNow  Boolean
  verified      Boolean
  updatedAt     DateTime          @updatedAt
  specialist    SpecialistProfile @relation(fields: [specialistId], references: [id], onDelete: Cascade)

  @@index([badge, ratingAvg, ratingCount], map: "idx_ssi_rank")
  @@index([centerLat, centerLng], map: "idx_ssi_geo")
  @@index([availableNow])
}

model EmailOtp {
  id        String    @id @default(cuid())
  createdAt DateTime  @default(now())
  email     String
  code      String
  expiresAt DateTime
  usedAt    DateTime?
  attempts  Int       @default(0)

  @@index([email])
  @@index([expiresAt])
}

model KycSubmission {
  id              String             @id @default(cuid())
  specialistId    String
  dniFrontUrl     String
  dniBackUrl      String
  selfieUrl       String
  status          VerificationStatus @default(PENDING)
  reviewerId      String?
  rejectionReason String?
  createdAt       DateTime           @default(now())
  reviewedAt      DateTime?
  specialist      SpecialistProfile  @relation(fields: [specialistId], references: [id], onDelete: Cascade)

  @@index([specialistId, status])
}

model SpecialistCertification {
  id              String            @id @default(cuid())
  specialistId    String
  categoryId      String
  fileUrl         String
  number          String?
  issuer          String?
  expiresAt       DateTime?
  status          CertStatus        @default(PENDING)
  createdAt       DateTime          @default(now())
  updatedAt       DateTime          @updatedAt
  rejectionReason String?
  reviewedAt      DateTime?
  reviewerId      String?
  category        ServiceCategory   @relation(fields: [categoryId], references: [id])
  specialist      SpecialistProfile @relation(fields: [specialistId], references: [id])

  @@unique([specialistId, categoryId], name: "specialistId_categoryId")
}

model PushToken {
  id        String   @id @default(cuid())
  userId    String
  token     String   @unique
  platform  String?
  enabled   Boolean  @default(true)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  user      User     @relation("UserPushTokens", fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
}

model SpecialistBackgroundCheck {
  id              String                @id @default(cuid())
  specialistId    String                @unique
  fileUrl         String
  status          BackgroundCheckStatus @default(PENDING)
  reviewerId      String?
  rejectionReason String?
  reviewedAt      DateTime?
  createdAt       DateTime              @default(now())
  updatedAt       DateTime              @updatedAt
  specialist      SpecialistProfile     @relation(fields: [specialistId], references: [id], onDelete: Cascade)

  @@index([status])
}

enum Role {
  ADMIN
  CUSTOMER
  SPECIALIST
}

enum UserStatus {
  ACTIVE
  BLOCKED
}

enum OrderStatus {
  PENDING
  ASSIGNED
  IN_PROGRESS
  PAUSED
  FINISHED_BY_SPECIALIST
  IN_CLIENT_REVIEW
  CONFIRMED_BY_CLIENT
  REJECTED_BY_CLIENT
  CANCELLED_BY_CUSTOMER
  CANCELLED_AUTO
  CLOSED
  CANCELLED_BY_SPECIALIST
}

enum VerificationStatus {
  UNVERIFIED
  PENDING
  VERIFIED
  REJECTED
}

enum Badge {
  BRONZE
  SILVER
  GOLD
  PLATINUM
}

enum SubscriptionStatus {
  TRIALING
  ACTIVE
  PAST_DUE
  CANCELLED
}

enum CertStatus {
  PENDING
  APPROVED
  REJECTED
}

enum BackgroundCheckStatus {
  PENDING
  APPROVED
  REJECTED
}

enum ServiceMode {
  HOME
  OFFICE
  ONLINE
}
