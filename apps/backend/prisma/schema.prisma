// Solucity ‚Äî schema.prisma (v1 eficiente, relaciones corregidas)
// DB: PostgreSQL

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

/**
 * ===================== Enums =====================
 */

enum Role {
  ADMIN
  CUSTOMER
  SPECIALIST
}

enum UserStatus {
  ACTIVE
  BLOCKED
}

enum OrderStatus {
  PENDING
  ASSIGNED
  IN_PROGRESS
  PAUSED
  FINISHED_BY_SPECIALIST
  IN_CLIENT_REVIEW
  CONFIRMED_BY_CLIENT
  REJECTED_BY_CLIENT
  CANCELLED_BY_CUSTOMER
  CANCELLED_BY_SPECIALIST
  CANCELLED_AUTO
  CLOSED
}

enum VerificationStatus {
  UNVERIFIED
  PENDING
  VERIFIED
  REJECTED
}

enum Badge {
  BRONZE
  SILVER
  GOLD
  PLATINUM
}

enum SubscriptionStatus {
  TRIALING
  ACTIVE
  PAST_DUE
  CANCELLED
}

enum CertStatus {
  PENDING
  APPROVED
  REJECTED
}

enum BackgroundCheckStatus {
  PENDING
  APPROVED
  REJECTED
}

/**
 * ===================== Core: Identidad =====================
 */

model User {
  id               String     @id @default(cuid())
  // Cambiar a opcional:
  phone            String?    @unique
  // Cambiar a requerido:
  email            String     @unique
  name             String?
  surname          String?
  passwordHash     String
  role             Role
  status           UserStatus @default(ACTIVE)
  twoFactorEnabled Boolean    @default(false)
  failedLoginCount Int        @default(0)
  lastLoginAt      DateTime?
  createdAt        DateTime   @default(now())
  updatedAt        DateTime   @updatedAt

  specialist       SpecialistProfile?
  customer         CustomerProfile?
  refreshTokens    RefreshToken[]
  termsAcceptances TermsAcceptance[]
  preferences      UserPreference?
  passwordsReset   PasswordReset[]
  notifications    Notification[]

  pushTokens PushToken[] @relation("UserPushTokens")

  orderEvents  OrderEvent[]  @relation("UserOrderEvents")
  reviewsGiven Rating[]      @relation("UserReviews")
  chatMessages ChatMessage[] @relation("UserChatMessages")

  @@index([status])
  @@index([lastLoginAt])
}

model CustomerProfile {
  id               String   @id @default(cuid())
  user             User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId           String   @unique
  defaultAddress   Address? @relation("CustomerDefaultAddress", fields: [defaultAddressId], references: [id])
  defaultAddressId String?

  avatarUrl String?

  orders    ServiceOrder[] @relation("CustomerOrders")
  createdAt DateTime       @default(now())
  updatedAt DateTime       @updatedAt
}

model SpecialistProfile {
  id     String @id @default(cuid())
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId String @unique

  bio               String?
  specialtyHeadline String? @db.VarChar(60)
  visitPrice        Int?
  pricingLabel      String?
  currency          String?
  availableNow      Boolean @default(false)

  // Verificaci√≥n y m√©tricas
  kycStatus     VerificationStatus @default(UNVERIFIED)
  points        Int                @default(0)
  badge         Badge              @default(BRONZE)
  ratingAvg     Float              @default(0)
  ratingCount   Int                @default(0)
  statsFinished Int                @default(0)
  statsCanceled Int                @default(0)

  // Cobertura y disponibilidad
  centerLat    Float?
  centerLng    Float?
  radiusKm     Float?
  availability Json?

  // Rubros
  specialties SpecialistSpecialty[]

  // üîπ Back-relations necesarios
  kycSubmissions  KycSubmission[]
  certifications  SpecialistCertification[]
  backgroundCheck SpecialistBackgroundCheck?

  // Operativa
  orders       ServiceOrder[]         @relation("SpecialistOrders")
  subscription Subscription?
  searchIndex  SpecialistSearchIndex?

  avatarUrl String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([badge, ratingAvg, points], map: "idx_spec_rank")
  @@index([availableNow])
}

/**
 * puente especialista‚Üîcategor√≠a (rubro)
 */
model SpecialistSpecialty {
  id           String            @id @default(cuid())
  specialist   SpecialistProfile @relation(fields: [specialistId], references: [id], onDelete: Cascade)
  specialistId String
  category     ServiceCategory   @relation(fields: [categoryId], references: [id], onDelete: Restrict)
  categoryId   String

  @@unique([specialistId, categoryId])
  @@index([categoryId])
}

/**
 * ===================== Cat√°logo =====================
 */

model ServiceCategoryGroup {
  id        String  @id @default(cuid())
  name      String  @unique
  slug      String  @unique
  isActive  Boolean @default(true)
  sortOrder Int?
  icon      String?
  color     String?

  categories ServiceCategory[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model ServiceCategory {
  id       String               @id @default(cuid())
  group    ServiceCategoryGroup @relation(fields: [groupId], references: [id], onDelete: Restrict)
  groupId  String
  name     String
  slug     String               @unique
  isActive Boolean              @default(true)

  requiresCertification Boolean @default(false)

  services Service[]
  specs    SpecialistSpecialty[]

  // üîπ Back-relation para certificaciones por rubro
  certifications SpecialistCertification[] // üëà NUEVO

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([groupId, name])
  @@index([groupId])
}

model Service {
  id          String          @id @default(cuid())
  category    ServiceCategory @relation(fields: [categoryId], references: [id], onDelete: Restrict)
  categoryId  String
  name        String
  description String?
  basePoints  Int             @default(0)
  slaHours    Int             @default(0)
  basePrice   Int?

  orders ServiceOrder[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([categoryId, name])
  @@index([categoryId])
}

/**
 * ===================== Address (con back-relations) =====================
 */

model Address {
  id        String  @id @default(cuid())
  formatted String
  lat       Float
  lng       Float
  placeId   String?

  // back-relations
  customerDefaults CustomerProfile[] @relation("CustomerDefaultAddress")
  orderLocations   ServiceOrder[]    @relation("OrderLocation")

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([lat, lng])
}

/**
 * ===================== Operaci√≥n (√≥rdenes) =====================
 */

model ServiceOrder {
  id           String             @id @default(cuid())
  customer     CustomerProfile    @relation("CustomerOrders", fields: [customerId], references: [id], onDelete: Restrict)
  customerId   String
  specialist   SpecialistProfile? @relation("SpecialistOrders", fields: [specialistId], references: [id])
  specialistId String?
  service      Service            @relation(fields: [serviceId], references: [id], onDelete: Restrict)
  serviceId    String
  location     Address?           @relation("OrderLocation", fields: [locationId], references: [id])
  locationId   String?

  addressText String?

  status                   OrderStatus @default(PENDING)
  description              String?
  attachments              Json?
  scheduledAt              DateTime?
  preferredAt              DateTime?
  isUrgent                 Boolean     @default(false)
  autoCancelAt             DateTime?
  acceptDeadlineAt         DateTime?
  acceptDeadlineExtendedAt DateTime?
  agreedPrice              Int?

  events     OrderEvent[]
  rating     Rating?
  chatThread ChatThread?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([status, scheduledAt], map: "idx_order_status_sched")
  @@index([customerId, status], map: "idx_order_customer")
  @@index([specialistId, status], map: "idx_order_specialist")
  @@index([status, acceptDeadlineAt], name: "idx_serviceOrder_status_deadline")
}

model OrderEvent {
  id        String       @id @default(cuid())
  order     ServiceOrder @relation(fields: [orderId], references: [id], onDelete: Cascade)
  orderId   String
  actor     User         @relation("UserOrderEvents", fields: [actorId], references: [id], onDelete: Restrict)
  actorId   String
  type      String
  payload   Json?
  createdAt DateTime     @default(now())

  @@index([orderId, createdAt])
}

model Rating {
  order      ServiceOrder @relation(fields: [orderId], references: [id], onDelete: Cascade)
  orderId    String       @id
  reviewer   User         @relation("UserReviews", fields: [reviewerId], references: [id], onDelete: Restrict)
  reviewerId String
  score      Int
  comment    String?
  tags       Json?
  createdAt  DateTime     @default(now())
}

/**
 * ===================== Comunicaci√≥n =====================
 */

model ChatThread {
  id        String        @id @default(cuid())
  order     ServiceOrder  @relation(fields: [orderId], references: [id], onDelete: Cascade)
  orderId   String        @unique
  messages  ChatMessage[]
  createdAt DateTime      @default(now())
}

model ChatMessage {
  id          String     @id @default(cuid())
  thread      ChatThread @relation(fields: [threadId], references: [id], onDelete: Cascade)
  threadId    String
  sender      User       @relation("UserChatMessages", fields: [senderId], references: [id], onDelete: Restrict)
  senderId    String
  body        String
  attachments Json?
  deliveredAt DateTime?
  readAt      DateTime?
  createdAt   DateTime   @default(now())

  @@index([threadId, createdAt])
}

model Notification {
  id        String    @id @default(cuid())
  user      User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId    String
  type      String
  title     String
  body      String
  data      Json?
  readAt    DateTime?
  createdAt DateTime  @default(now())

  @@index([userId, readAt])
}

/**
 * ===================== Suscripciones =====================
 */

model Subscription {
  id                 String             @id @default(cuid())
  specialist         SpecialistProfile  @relation(fields: [specialistId], references: [id], onDelete: Cascade)
  specialistId       String             @unique
  status             SubscriptionStatus @default(TRIALING)
  currentPeriodStart DateTime
  currentPeriodEnd   DateTime
  trialEnd           DateTime?

  provider          String? // "MERCADOPAGO"
  providerSubId     String? // id de la suscripci√≥n en MP
  lastPaymentStatus String? // approved | pending | rejected
  lastPaymentId     String? //

  createdAt DateTime @default(now())
  updatedAt DateTime @default(now()) @updatedAt

  @@index([specialistId, status])
}

/**
 * ===================== Auth & Preferencias =====================
 */

model TermsAcceptance {
  id         String   @id @default(cuid())
  user       User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId     String
  version    String
  ip         String?
  userAgent  String?
  acceptedAt DateTime @default(now())

  @@index([userId, version])
}

model RefreshToken {
  id        String   @id @default(cuid())
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId    String
  token     String   @unique
  userAgent String?
  ip        String?
  expiresAt DateTime
  createdAt DateTime @default(now())

  @@index([userId, expiresAt])
}

model PasswordReset {
  id        String    @id @default(cuid())
  user      User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId    String
  otp       String
  expiresAt DateTime
  usedAt    DateTime?
  createdAt DateTime  @default(now())

  @@index([userId, expiresAt])
}

model UserPreference {
  id            String  @id @default(cuid())
  user          User    @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId        String  @unique
  theme         String? // "light" | "dark" | "system"
  notifications Json?
}

/**
 * ===================== Proyecci√≥n de b√∫squeda =====================
 */
/**
 * Para listados r√°pidos sin joins (se actualiza por jobs)
 */

model SpecialistSearchIndex {
  id           String            @id @default(cuid())
  specialist   SpecialistProfile @relation(fields: [specialistId], references: [id], onDelete: Cascade)
  specialistId String            @unique

  groupSlugs    String[] // ej: ["construccion","mantenimiento"]
  categorySlugs String[] // ej: ["plomero","electricista"]
  centerLat     Float
  centerLng     Float
  radiusKm      Float
  ratingAvg     Float
  ratingCount   Int
  badge         Badge
  visitPrice    Int?
  availableNow  Boolean
  verified      Boolean // derivado: kycStatus == VERIFIED o credencial v√°lida

  updatedAt DateTime @updatedAt

  @@index([badge, ratingAvg, ratingCount], map: "idx_ssi_rank")
  @@index([centerLat, centerLng], map: "idx_ssi_geo")
  @@index([availableNow])
}

model EmailOtp {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())

  email     String
  code      String // 6 d√≠gitos
  expiresAt DateTime
  usedAt    DateTime?
  attempts  Int       @default(0)

  @@index([email])
  @@index([expiresAt])
}

// schema.prisma (agrega al final)
model KycSubmission {
  id              String             @id @default(cuid())
  specialist      SpecialistProfile  @relation(fields: [specialistId], references: [id], onDelete: Cascade)
  specialistId    String
  dniFrontUrl     String
  dniBackUrl      String
  selfieUrl       String
  status          VerificationStatus @default(PENDING) // usa tu enum
  reviewerId      String?
  rejectionReason String?
  createdAt       DateTime           @default(now())
  reviewedAt      DateTime?

  @@index([specialistId, status])
}

model SpecialistCertification {
  id           String            @id @default(cuid())
  specialist   SpecialistProfile @relation(fields: [specialistId], references: [id])
  specialistId String

  category   ServiceCategory @relation(fields: [categoryId], references: [id])
  categoryId String

  fileUrl   String
  number    String?
  issuer    String?
  expiresAt DateTime?

  status          CertStatus @default(PENDING)
  reviewerId      String?
  rejectionReason String?
  reviewedAt      DateTime?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([specialistId, categoryId], name: "specialistId_categoryId")
}

model PushToken {
  id        String   @id @default(cuid())
  user      User     @relation("UserPushTokens", fields: [userId], references: [id], onDelete: Cascade)
  userId    String
  token     String   @unique
  platform  String?
  enabled   Boolean  @default(true)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([userId])
}

model SpecialistBackgroundCheck {
  id           String            @id @default(cuid())
  specialistId String            @unique
  specialist   SpecialistProfile @relation(fields: [specialistId], references: [id], onDelete: Cascade)

  fileUrl String
  status  BackgroundCheckStatus @default(PENDING)

  reviewerId      String? // admin userId
  rejectionReason String?
  reviewedAt      DateTime?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([status])
}
